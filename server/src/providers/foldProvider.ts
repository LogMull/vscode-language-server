import { DocumentSymbol, FoldingRange, FoldingRangeKind } from 'vscode-languageserver';
import { TextDocument } from 'vscode-languageserver-textdocument';
import { symbolLocationToRange } from './utils'

/// This function will provide folding range information for a given set of document symbols.
export async function provideFoldRanges(document: TextDocument, clientMethodSymbols: DocumentSymbol[]): Promise<FoldingRange[]> {

	let finalRanges: FoldingRange[] = [];

	try {
		// Iterate over all symbols
		for (const symbol of clientMethodSymbols) {
			const range = symbolLocationToRange(symbol)
			// Find all pairs of braces
			let pairs = findBracePairs(document.getText(range))

			for (let pair of pairs) {
				// Create a position for each brace and use their locations
				let rangeStart = document.offsetAt(range.start);
				let startPos = document.positionAt(rangeStart + pair.start);
				let endPos = document.positionAt(rangeStart + pair.end);
				const foldingRange = FoldingRange.create(
					startPos.line,
					endPos.line - 1,
					startPos.character,
					endPos.character
				);
				// Skip any mal-formed ranges and any which are on the same line
				if (foldingRange.startLine == foldingRange.endLine || foldingRange.startLine > foldingRange.endLine) continue;
				finalRanges.push(foldingRange);
				foldingRange.kind = FoldingRangeKind.Region;
				// foldingRange.collapsedText = `LCM AHHH ${count}`;
			}
		}
	} catch (ex) {
		console.log("Exception in range provider:");
		console.log(ex)
	}

	return Promise.resolve(finalRanges);
}

interface BracePair {
	start: number;
	end: number;
}
/// Generated by chat GPT, this will iterate over the method and match every { and } pair, excluding any that may appear in a comment or a string.
/// This is not perfect, for example some may appear in an unqupted regex and that will cause breaking of the ranges.
function findBracePairs(text: string): BracePair[] {
	const pairs: BracePair[] = [];
	const stack: number[] = [];
	let insideComment = false;
	let insideString = false;
	let currentQuoteChar: string | null = null;

	for (let i = 0; i < text.length; i++) {
		const char = text[i];

		if (char === '{' && !insideComment && !insideString) {
			stack.push(i);
		} else if (char === '}' && !insideComment && !insideString) {
			if (stack.length > 0) {
				const start = stack.pop()!;
				pairs.push({
					start,
					end: i
				});
			}
		} else if (char === '/' && text[i + 1] === '*' && !insideString) {
			insideComment = true;
		} else if (char === '*' && text[i + 1] === '/' && !insideString) {
			insideComment = false;
			i++; // Skip the '*' in '*/'
		} else if ((char === '\'' || char === '"' || char ==='`') && !insideComment) {
			if (insideString && currentQuoteChar === char) {
				// Closing quote, toggle insideString off
				insideString = false;
				currentQuoteChar = null;
			} else if (!insideString) {
				// Opening quote, toggle insideString on
				insideString = true;
				currentQuoteChar = char;
			}
		} else if (char === '\\' && insideString) {
			// Handle escaped quotes
			i++;
		}
	}

	return pairs;
}
